# 树

## 二叉搜索树

​		容易退化成链表，退化复杂度由logn退化成n
## 平衡二叉树
​		规定二叉搜索树的子树高度差不超过1，需要通过频繁的旋转来维护平衡的特性
## 红黑树
​		牺牲平衡二叉树的高度差的规定，add旋转操作不超过两次，del旋转操作不超过3次，整体性能logn，优于平衡二叉树
​		红黑树规定：
​			1、节点非红即黑
​			2、根节点黑
​			3、NULL节点为黑
​			4、任意路径上不存在连续的红节点
​			5、任意节点到叶子节点的路径黑色节点数目相同
​			6、新加入的节点为红（推断出，不是红黑树的规定）
​		更改主要考虑两个因素:
​			是否有连续红节点
​			是否更改了原路径上得黑色节点数

# 堆
​	完全二叉树的结构，在存储过程中一般直接用数组，i的叶子节点是2i+1 2i+2，某个节点的父节点是i/2向下取整
​	大顶堆：每个节点的子节点都不大于他

```C++
priority_queue<int>  big_heap; // 默认大顶堆
priority_queue<int, vector<int>, less<int>> big_heap; // less指定为大顶堆

priority_queue<int, vector<int>, greater<int>> little_heap; // 指定greater为小顶堆 
```

# hash
​	hash函数
​		直接定地
​		数字分析
​		折叠
​		随机数
​		除留余数
​		平房取中
​	冲突解决
​		开发定址
​			线性探测再散列y = (x + d) mod m d = 1,2,3,4,5....
​			二次探测再散列 y = (x + d) mod m d = 1^2 -1^2 2^2 -2^2
​			伪随机探测再散列
​		公共溢出区
​		连地址/红黑树
​		再哈希

# STL
	## unordered_map
​		hash表实现，hash冲突时使用红黑树结构保存
​	## map
​		红黑树保存，中序遍历就是有序
​	## vector
​	## priority_queue
## queue

堆排序

图的两种遍历，优缺点

# 面向对象三大特征

## 封装

## 继承

## 多态
### 编译多态（泛型）
​		通过函数重载以及操作符重载实现：编译阶段编译器会把函数名扩展成名字+参数类型列表的形式，链接阶段根据不同的参数列表调用不同的函数
### 运行多态
​		通过继承和虚函数实现
​		虚函数：
​			virtual void func()，基类内部可以实现也可以不实现，派生类可以实现也可以不实现
​		纯虚函数：
​			virtual void func() = 0基类内部不会实现，要求派生类内部必须实现，这样调用的时候是派生类的函数
​		抽象类：
​			内部具有纯虚函数的类就是抽象类，抽象类不能够实例化，不能够作为函数入参，比如Shape类，Circle和Rectangle类继承shape类
​		运行时的多态一般使用父类的指针指向子类的对象，通过指针调用类内部函数的时候，对于非虚函数，调用父类的实现，对于虚函数和纯虚函数，调用子类的实现
​		虚函数表：
​			https://blog.csdn.net/xiaxzhou/article/details/76576516
​			具有虚函数的虚基类和由他派生出的子类，都默认具有一个虚函数表，因此sizeof时会多一个指针的大小
​			p->func()运行过程中，根据取出指针所指地址的前4字节或者8字节，找到虚函数表，在表中查找对应的func函数，如果子类没有重载父类的虚函数，则子类的虚函数表中func是父类的实现，也会调用到父类的func
​		构造函数
​			构造函数不可以是虚函数，因为构造函数不允许被子类重载
​			而析构函数往往是虚的
​		虚析构函数
​			Farther* p = new Son()       delete p
​			虚基类的析构函数一定要是虚的，因为如果非虚，则delete的时候无法使用多态，只会调用父类的析构，无法调用到子类
​		纯虚析构函数
​			当需要一个类作为抽象类，但是又找不到可以定义成纯虚函数时，可以把析构函数定义成纯虚函数
​			纯虚析构函数要求，一定要给出实现，因为在多态使用中，析构函数是需要被调用的，如果不给实现，则无法调用，此时编译的链接阶段会报错，提示找不到基类虚构函数的实现
​			
​		
私有构造函数
​	不希望外部对类进行实例化，典型场景是单例
​	使用公共静态函数，独立于对象存在，可以通过类调用
​	class Single{
​	public:
​		static Single getIns() {
​			if (p == NULL) {
​				p = new Single();
​			}
​			return p;
​		}
​	private:
​		static Single* p;
​		Single() {}

}			

C++内存管理
	栈
	堆
	静态
	全局
	BSS

阻止拷贝
	对象拷贝，两种方式：拷贝构造函数和赋值操作符=
	为了阻止对象拷贝，可以把拷贝构造函数和重载后的=声明成private
	class NoCopy {
	public:
		NoCopy(){};
		~NoCopy(){};
		
	private:
		NoCopy(const NoCopy& c) {}
		const NoCopy& operator = (const NoCopy& c) {};
	}

# 浅拷贝 & 深拷贝

浅拷贝类似于memcpy，对象中没有指针变量的时候，一般浅拷贝即可

深拷贝需要实现拷贝构造函数，一般适用于对象成员有指针的情况，或者是类在创建时需要特殊操作的情况（比如记录创建时间）

# 左值 & 右值

左值：可以被引用的数据对象，比如变量、数组元素、结构体成员、引用、解引用

右值：常量、有多项的表达式(例如：n + 4)

# 引用 & 指针

引用类似于指针常量 int *const p = &a，此时不允许改变p的指向，但是可以改变p指向的内容的值

引用是变量的别名；指针是变量的地址

引用声明的时候必须初始化，且不可以改变“指向”的对象；指针声明的时候可以不初始化，也可以改变指向的对象

作为函数参数时，指针在函数栈里面需要占用4Byte/8Byte的大小；引用作为别名不需要

引用作为形参的时候，调用者不用关心函数是值传递函数引用传递，传变量名即可；指针做为形参的时候，调用者必须传入变量的指针

引用作为函数形参时，调用时实参不能传入表达式func(n + 3)；值传递是可以

# extern "C"
​	一般用户头文件
​	C++编译阶段会将函数名扩展成包含参数列表的形式，C编译不会，因此C++代码调用C语言实现的函数时，可能出现函数未定义的情况
​	用了extern “C”修饰的代码，会使用C语言的编译方式，不会扩展函数名

C++寻址栈在前还是堆在前
	
如何让对象只分配在栈上
	重载new delete
	

# C++ 11 新特性

lambda表达式（闭包）

右值引用 &&

移动语义

智能指针

auto泛型

# C++ 14 新特性

# 模板
​	好处
​		灵活性，扩展性
​		相比于多态性能优异，没有继承，不需要虚函数寻址
​	缺点
​		编译阶段确定数据类型，
​		可读性不好
​	

# 内联函数和宏的区别

# 迭代器

迭代器失效

```C++
// 错误代码
for (map<int. int>::iterator it = m.begin(); it != m.end(); it++) {
    if (...) {
        m.erase(it); // 此时会迭代器失效，erase之后，it后面的迭代器都会失效，再进行for循环中的it++，就会导致内存访问出错
    }
}
```

```C++
// 正确代码
for (map<int. int>::iterator it = m.begin(); it != m.end(); /* it不在此处自增 */) {
    if (...) {
        m.erase(it++); // erase传入it++，会生成一个临时变量作为erase的参数，it在erase前自增，因此不会发生失效
    } else {	
        it++;
    }
}
```



# C++设计模式
## 单例模式

```C++
// 懒汉模式：系统运行的时候不创建单例对象，只有在第一次使用是才创建
class Singleton {
private:
    Singleton(); // 构造函数私有，不允许在外部构造
    ~Singleton();
    Singleton(const Singleton& s); // 拷贝构造函数私有
    const Singleton& operator=(const Singleton& s); // 重载=操作符，私有，不允许外部拷贝
	static Singleton* instancePtr; // 单例对象的指针
    static mutex singletonMutex;
    
public:
    static Singleton& getInstance() { // 对外暴露getInstance接口，用于获取单例对象的引用
        if (instancePtr == NULL) { // 先判断是否为NULL，非NULL的时候可以直接返回，不需要lock
            singletonMutex.lock();
            if (instancePtr == NULL) { // lock之后还需要再判断一次非NULL，否则可能lock前已经创建对象
                instancePtr = new Singleton();
            }
            singletonMutex.unlock();
        }
        
        return *instancePtr; // 返回引用，防止返回指针时外部使用delete删除
    }
};
```

```C++
// 饿汉模式：系统运行的时候立马创建对象

```



	## 工厂模式
	## 适配器模式
	## 策略模式

#  C++运算符优先级

() [] -> .

++ -- ! ~ - * (int) & sizeof

\* / %

\+ -

<< >>

< <=

\> \>=

== !=

&

^

|

&&

||

? :

= += -= %= *= %=
,

快速排序
		
topK
	小顶堆
	快排变种
	
const int* p 常量指针，不能改变p指向的常量的值，但是可以改变p的指向
int* const p 指针常量，不能改变p本身，也就是不能改变p的指向，但是可以改变p指向的值

宏和常量
	宏在预编译阶段进行字符替换，不会进行安全检查，由于在预编译阶段进行替换，因此不会占用内存空间
	常量在运行阶段进行替换，可以进行安全检查，常量的值可以改变一次，即const int len; cin >> len;
	#define M 3   //宏常量
	const int N=5;  // 此时并未将N放入内存中

	int i=N;  //此时为N分配内存，以后不再分配！
	int I=M;  //预编译期间进行宏替换，分配内存
	int j=N;  //没有内存分配
	int J=M;  //再进行宏替换，又一次分配内存！

虚函数表一个类是否有多个
	虚继承多个

虚函数表编译阶段还是运行阶段确定
	编译预处理		处理编译宏
	编译			生成语法树，生成虚函数表 g++ -c
	汇编			机器码
	链接			多个文件链接成一个可执行程序 g++ -o 
	运行

线段树
	https://blog.csdn.net/huangzihaoal/article/details/81813454
	
字节对齐：32位系统默认4字节对齐，#pragma pack()可以设置对齐方式
	结构体成员每个变量的起始位置，是该成员长度的整数倍
	结构体整体长度是最大成员的整数倍
	结构体本身的首地址是其最宽成员大小的整数倍
	typedef struct bb
	{
		int id;             //[0]....[3]
		long long weight;      //[8].....[15]
		int height;      //[16]..[19], 但是为了保证
	} BB;

# malloc & new

|        特征        |              new/delete               |             malloc/free              |
| :----------------: | :-----------------------------------: | :----------------------------------: |
|   分配内存的位置   |              自由存储区               |                  堆                  |
| 内存分配失败返回值 |             完整类型指针              |                void*                 |
| 内存分配失败返回值 |             默认抛出异常              |               返回NULL               |
|   分配内存的大小   |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|      处理数组      |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|  已分配内存的扩充  |            无法直观地处理             |         使用realloc简单完成          |
|    是否相互调用    | 可以，看具体的operator new/delete实现 |             不可调用new              |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|      函数重载      |                 允许                  |                不允许                |
| 构造函数与析构函数 |                 调用                  |                不调用                |